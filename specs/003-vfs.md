# 003: Virtual Filesystem Design

## Status
Implemented (InMemoryFs, OverlayFs, MountableFs)

## Decision

BashKit uses an async virtual filesystem trait with multiple implementations.

### FileSystem Trait

```rust
#[async_trait]
pub trait FileSystem: Send + Sync {
    // Read operations
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>>;
    async fn stat(&self, path: &Path) -> Result<Metadata>;
    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>>;
    async fn exists(&self, path: &Path) -> Result<bool>;
    async fn read_link(&self, path: &Path) -> Result<PathBuf>;

    // Write operations
    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn append_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn mkdir(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn remove(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn rename(&self, from: &Path, to: &Path) -> Result<()>;
    async fn copy(&self, from: &Path, to: &Path) -> Result<()>;
    async fn symlink(&self, target: &Path, link: &Path) -> Result<()>;
    async fn chmod(&self, path: &Path, mode: u32) -> Result<()>;
}
```

### Public API

All filesystem types are exported from the crate root:

```rust
pub use bashkit::{
    // Trait and types for implementing custom filesystems
    async_trait,       // Re-exported for convenience
    FileSystem,        // The trait to implement
    FileType,          // File/Directory/Symlink enum
    Metadata,          // File metadata struct
    DirEntry,          // Directory entry struct
    Result,            // Result type alias
    Error,             // Error type

    // Built-in implementations
    InMemoryFs,        // In-memory filesystem
    OverlayFs,         // Copy-on-write overlay
    MountableFs,       // Multiple mount points
};
```

### Metadata

```rust
pub struct Metadata {
    pub file_type: FileType,
    pub size: u64,
    pub mode: u32,        // Unix permissions
    pub modified: SystemTime,
    pub created: SystemTime,
}

pub enum FileType {
    File,
    Directory,
    Symlink,
}

pub struct DirEntry {
    pub name: String,
    pub metadata: Metadata,
}
```

### Implementations

#### InMemoryFs (Implemented)
- All files stored in `HashMap<PathBuf, FsEntry>`
- Thread-safe via `RwLock`
- Initial directories: `/`, `/tmp`, `/home`, `/home/user`, `/dev`
- Special handling for `/dev/null`
- No persistence - state lost on drop

#### OverlayFs (Implemented)
- Copy-on-write layer over another FileSystem
- Read from base, write to overlay
- Whiteout tracking for deleted files
- Useful for: temp modifications, testing, sandboxing

```rust
pub struct OverlayFs {
    lower: Arc<dyn FileSystem>,
    upper: InMemoryFs,
    whiteouts: RwLock<HashSet<PathBuf>>,
}
```

#### MountableFs (Implemented)
- Mount multiple filesystems at different paths
- Like Unix mount points
- Longest-prefix matching for nested mounts

```rust
pub struct MountableFs {
    root: Arc<dyn FileSystem>,
    mounts: RwLock<BTreeMap<PathBuf, Arc<dyn FileSystem>>>,
}
```

#### RealFs (Planned, Optional)
- Direct access to real filesystem
- Must be explicitly enabled (security)
- Useful for development/testing

### Custom FileSystem Implementations

External crates can implement the FileSystem trait to bridge bashkit to custom storage backends. This is useful for:

1. **Session file stores** - Bridge to external storage during execution
2. **Database-backed filesystems** - Store files in a database
3. **Remote filesystems** - Access files over network protocols
4. **Cached filesystems** - Add caching layers

#### Required Imports

```rust
use bashkit::{
    async_trait, DirEntry, Error, FileSystem, FileType, Metadata, Result,
};
use std::path::{Path, PathBuf};
use std::time::SystemTime;
```

#### Implementation Pattern

```rust
pub struct CustomFileSystem {
    // Your storage backend
}

#[async_trait]
impl FileSystem for CustomFileSystem {
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>> {
        // Delegate to your storage
    }

    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()> {
        // Delegate to your storage
    }

    async fn stat(&self, path: &Path) -> Result<Metadata> {
        Ok(Metadata {
            file_type: FileType::File,
            size: content_len as u64,
            mode: 0o644,
            modified: SystemTime::now(),
            created: SystemTime::now(),
        })
    }

    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>> {
        // Return directory entries with metadata
    }

    // ... implement remaining methods
}
```

#### Usage

```rust
let custom_fs = Arc::new(CustomFileSystem::new());
let mut bash = Bash::builder().fs(custom_fs).build();
let result = bash.exec("cat /my/file.txt").await?;
```

See `examples/custom_filesystem_impl.rs` for a complete working example.

### Path Handling

All paths normalized before use:
- Resolve `.` and `..` components
- Remove trailing slashes
- Ensure absolute paths start with `/`

```rust
fn normalize_path(path: &Path) -> PathBuf {
    // "/foo/../bar/./baz" -> "/bar/baz"
}
```

### Symlink Handling

Current: Symlinks stored but not followed (TODO comment in code)
Planned: Follow symlinks with loop detection (max 40 levels like Linux)

### Error Handling

All operations return `Result<T>` with IO errors:
- `NotFound` - file/directory doesn't exist
- `AlreadyExists` - path already exists
- `Other("is a directory")` - operation not valid for directories
- `Other("not a directory")` - expected directory
- `Other("directory not empty")` - non-recursive delete of non-empty dir

## Alternatives Considered

### Real filesystem with chroot
Rejected because:
- Requires root privileges
- Not portable across OSes
- Doesn't work in WASM

### tokio::fs wrapper
Rejected because:
- Always hits real filesystem
- Can't sandbox or virtualize
- No multi-tenant isolation

## Verification

```rust
#[tokio::test]
async fn test_write_and_read() {
    let fs = InMemoryFs::new();
    fs.write_file(Path::new("/tmp/test"), b"hello").await.unwrap();
    let content = fs.read_file(Path::new("/tmp/test")).await.unwrap();
    assert_eq!(content, b"hello");
}

#[tokio::test]
async fn test_mkdir_recursive() {
    let fs = InMemoryFs::new();
    fs.mkdir(Path::new("/a/b/c"), true).await.unwrap();
    assert!(fs.exists(Path::new("/a")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b/c")).await.unwrap());
}

#[tokio::test]
async fn test_custom_filesystem_integration() {
    // Custom filesystems work with Bash
    let custom_fs = Arc::new(MyCustomFs::new());
    let mut bash = Bash::builder().fs(custom_fs).build();
    let result = bash.exec("echo test > /tmp/file && cat /tmp/file").await.unwrap();
    assert_eq!(result.stdout, "test\n");
}
```
