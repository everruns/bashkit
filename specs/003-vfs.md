# 003: Virtual Filesystem Design

## Status
Implemented (InMemoryFs), Planned (OverlayFs, MountableFs)

## Decision

BashKit uses an async virtual filesystem trait with multiple implementations.

### FileSystem Trait

```rust
#[async_trait]
pub trait FileSystem: Send + Sync {
    // Read operations
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>>;
    async fn stat(&self, path: &Path) -> Result<Metadata>;
    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>>;
    async fn exists(&self, path: &Path) -> Result<bool>;
    async fn read_link(&self, path: &Path) -> Result<PathBuf>;

    // Write operations
    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn append_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn mkdir(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn remove(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn rename(&self, from: &Path, to: &Path) -> Result<()>;
    async fn copy(&self, from: &Path, to: &Path) -> Result<()>;
    async fn symlink(&self, target: &Path, link: &Path) -> Result<()>;
    async fn chmod(&self, path: &Path, mode: u32) -> Result<()>;
}
```

### Metadata

```rust
pub struct Metadata {
    pub file_type: FileType,
    pub size: u64,
    pub mode: u32,        // Unix permissions
    pub modified: SystemTime,
    pub created: SystemTime,
}

pub enum FileType {
    File,
    Directory,
    Symlink,
}

pub struct DirEntry {
    pub name: String,
    pub metadata: Metadata,
}
```

### Implementations

#### InMemoryFs (Implemented)
- All files stored in `HashMap<PathBuf, FsEntry>`
- Thread-safe via `RwLock`
- Initial directories: `/`, `/tmp`, `/home`, `/home/user`
- No persistence - state lost on drop

#### OverlayFs (Planned)
- Copy-on-write layer over another FileSystem
- Read from base, write to overlay
- Useful for: temp modifications, testing, sandboxing

```rust
pub struct OverlayFs {
    base: Arc<dyn FileSystem>,
    overlay: InMemoryFs,
    deleted: HashSet<PathBuf>,  // Whiteout files
}
```

#### MountableFs (Planned)
- Mount multiple filesystems at different paths
- Like Unix mount points

```rust
pub struct MountableFs {
    root: Arc<dyn FileSystem>,
    mounts: BTreeMap<PathBuf, Arc<dyn FileSystem>>,
}
```

#### RealFs (Planned, Optional)
- Direct access to real filesystem
- Must be explicitly enabled (security)
- Useful for development/testing

### Path Handling

All paths normalized before use:
- Resolve `.` and `..` components
- Remove trailing slashes
- Ensure absolute paths start with `/`

```rust
fn normalize_path(path: &Path) -> PathBuf {
    // "/foo/../bar/./baz" â†’ "/bar/baz"
}
```

### Symlink Handling

Current: Symlinks stored but not followed (TODO comment in code)
Planned: Follow symlinks with loop detection (max 40 levels like Linux)

### Error Handling

All operations return `Result<T>` with IO errors:
- `NotFound` - file/directory doesn't exist
- `AlreadyExists` - path already exists
- `Other("is a directory")` - operation not valid for directories
- `Other("not a directory")` - expected directory
- `Other("directory not empty")` - non-recursive delete of non-empty dir

## Alternatives Considered

### Real filesystem with chroot
Rejected because:
- Requires root privileges
- Not portable across OSes
- Doesn't work in WASM

### tokio::fs wrapper
Rejected because:
- Always hits real filesystem
- Can't sandbox or virtualize
- No multi-tenant isolation

## Verification

```rust
#[tokio::test]
async fn test_write_and_read() {
    let fs = InMemoryFs::new();
    fs.write_file(Path::new("/tmp/test"), b"hello").await.unwrap();
    let content = fs.read_file(Path::new("/tmp/test")).await.unwrap();
    assert_eq!(content, b"hello");
}

#[tokio::test]
async fn test_mkdir_recursive() {
    let fs = InMemoryFs::new();
    fs.mkdir(Path::new("/a/b/c"), true).await.unwrap();
    assert!(fs.exists(Path::new("/a")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b/c")).await.unwrap());
}
```
