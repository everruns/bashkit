# 003: Virtual Filesystem Design

## Status
Implemented (InMemoryFs, OverlayFs, MountableFs)

## Decision

BashKit uses an async virtual filesystem trait with multiple implementations.

### FileSystem Trait

```rust
#[async_trait]
pub trait FileSystem: Send + Sync {
    // Read operations
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>>;
    async fn stat(&self, path: &Path) -> Result<Metadata>;
    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>>;
    async fn exists(&self, path: &Path) -> Result<bool>;
    async fn read_link(&self, path: &Path) -> Result<PathBuf>;

    // Write operations
    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn append_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn mkdir(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn remove(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn rename(&self, from: &Path, to: &Path) -> Result<()>;
    async fn copy(&self, from: &Path, to: &Path) -> Result<()>;
    async fn symlink(&self, target: &Path, link: &Path) -> Result<()>;
    async fn chmod(&self, path: &Path, mode: u32) -> Result<()>;
}
```

### Public API

All filesystem types are exported from the crate root:

```rust
pub use bashkit::{
    // Trait and types for implementing custom filesystems
    async_trait,       // Re-exported for convenience
    FileSystem,        // The trait to implement
    FileType,          // File/Directory/Symlink enum
    Metadata,          // File metadata struct
    DirEntry,          // Directory entry struct
    Result,            // Result type alias
    Error,             // Error type

    // Built-in implementations
    InMemoryFs,        // In-memory filesystem
    OverlayFs,         // Copy-on-write overlay
    MountableFs,       // Multiple mount points
};
```

### Metadata

```rust
pub struct Metadata {
    pub file_type: FileType,
    pub size: u64,
    pub mode: u32,        // Unix permissions
    pub modified: SystemTime,
    pub created: SystemTime,
}

pub enum FileType {
    File,
    Directory,
    Symlink,
}

pub struct DirEntry {
    pub name: String,
    pub metadata: Metadata,
}
```

### Implementations

#### InMemoryFs (Implemented)
- All files stored in `HashMap<PathBuf, FsEntry>`
- Thread-safe via `RwLock`
- Initial directories: `/`, `/tmp`, `/home`, `/home/user`, `/dev`
- Special handling for `/dev/null`
- No persistence - state lost on drop
- Synchronous `add_file()` method for pre-population during construction

##### Mounting Files with BashBuilder

The `BashBuilder` provides convenience methods to mount files in the virtual filesystem:

```rust
let mut bash = Bash::builder()
    // Writable file (mode 0o644)
    .mount_text("/config/app.conf", "debug=true\nport=8080\n")
    // Readonly file (mode 0o444)
    .mount_readonly_text("/etc/version", "1.2.3")
    .build();
```

- `mount_text(path, content)` - Creates writable file (mode `0o644`)
- `mount_readonly_text(path, content)` - Creates readonly file (mode `0o444`)
- Parent directories are created automatically
- Works with any filesystem - mounted files are added via an OverlayFs layer

When mounted files are specified, they're added to an OverlayFs layer on top of
the base filesystem. This means:
- The base filesystem remains unchanged
- Mounted files take precedence over base filesystem files
- Works with both default InMemoryFs and custom filesystems

Use cases:
- Configuration files for scripts to read
- Reference data that shouldn't be modified
- Pre-seeding test fixtures
- Simulating system files like `/etc/passwd`

See `examples/text_files.rs` for comprehensive examples.

#### OverlayFs (Implemented)
- Copy-on-write layer over another FileSystem
- Read from base, write to overlay
- Whiteout tracking for deleted files
- Useful for: temp modifications, testing, sandboxing

```rust
pub struct OverlayFs {
    lower: Arc<dyn FileSystem>,
    upper: InMemoryFs,
    whiteouts: RwLock<HashSet<PathBuf>>,
}
```

#### MountableFs (Implemented)
- Mount multiple filesystems at different paths
- Like Unix mount points
- Longest-prefix matching for nested mounts

```rust
pub struct MountableFs {
    root: Arc<dyn FileSystem>,
    mounts: RwLock<BTreeMap<PathBuf, Arc<dyn FileSystem>>>,
}
```

#### RealFs (Planned, Optional)
- Direct access to real filesystem
- Must be explicitly enabled (security)
- Useful for development/testing

### Custom FileSystem Implementations

External crates can implement the FileSystem trait to bridge bashkit to custom storage backends. This is useful for:

1. **Session file stores** - Bridge to external storage during execution
2. **Database-backed filesystems** - Store files in a database
3. **Remote filesystems** - Access files over network protocols
4. **Cached filesystems** - Add caching layers

#### Required Imports

```rust
use bashkit::{
    async_trait, DirEntry, Error, FileSystem, FileType, Metadata, Result,
};
use std::path::{Path, PathBuf};
use std::time::SystemTime;
```

#### Implementation Pattern

```rust
pub struct CustomFileSystem {
    // Your storage backend
}

#[async_trait]
impl FileSystem for CustomFileSystem {
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>> {
        // Delegate to your storage
    }

    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()> {
        // Delegate to your storage
    }

    async fn stat(&self, path: &Path) -> Result<Metadata> {
        Ok(Metadata {
            file_type: FileType::File,
            size: content_len as u64,
            mode: 0o644,
            modified: SystemTime::now(),
            created: SystemTime::now(),
        })
    }

    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>> {
        // Return directory entries with metadata
    }

    // ... implement remaining methods
}
```

#### Usage

```rust
let custom_fs = Arc::new(CustomFileSystem::new());
let mut bash = Bash::builder().fs(custom_fs).build();
let result = bash.exec("cat /my/file.txt").await?;
```

See `examples/custom_filesystem_impl.rs` for a complete working example.

### Path Handling

All paths normalized before use:
- Resolve `.` and `..` components
- Remove trailing slashes
- Ensure absolute paths start with `/`

```rust
fn normalize_path(path: &Path) -> PathBuf {
    // "/foo/../bar/./baz" -> "/bar/baz"
}
```

### Symlink Handling

Symlinks are stored but intentionally not followed for security:
- **TM-ESC-002**: Prevents symlink escape attacks
- **TM-DOS-011**: Prevents symlink loop DoS attacks

See `specs/006-threat-model.md` for details.

### Error Handling

All operations return `Result<T>` with IO errors:
- `NotFound` - file/directory doesn't exist
- `AlreadyExists` - path already exists
- `Other("is a directory")` - operation not valid for directories
- `Other("not a directory")` - expected directory
- `Other("directory not empty")` - non-recursive delete of non-empty dir

## Alternatives Considered

### Real filesystem with chroot
Rejected because:
- Requires root privileges
- Not portable across OSes
- Doesn't work in WASM

### tokio::fs wrapper
Rejected because:
- Always hits real filesystem
- Can't sandbox or virtualize
- No multi-tenant isolation

## Verification

```rust
#[tokio::test]
async fn test_write_and_read() {
    let fs = InMemoryFs::new();
    fs.write_file(Path::new("/tmp/test"), b"hello").await.unwrap();
    let content = fs.read_file(Path::new("/tmp/test")).await.unwrap();
    assert_eq!(content, b"hello");
}

#[tokio::test]
async fn test_mkdir_recursive() {
    let fs = InMemoryFs::new();
    fs.mkdir(Path::new("/a/b/c"), true).await.unwrap();
    assert!(fs.exists(Path::new("/a")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b/c")).await.unwrap());
}

#[tokio::test]
async fn test_custom_filesystem_integration() {
    // Custom filesystems work with Bash
    let custom_fs = Arc::new(MyCustomFs::new());
    let mut bash = Bash::builder().fs(custom_fs).build();
    let result = bash.exec("echo test > /tmp/file && cat /tmp/file").await.unwrap();
    assert_eq!(result.stdout, "test\n");
}
```
