# 003: Virtual Filesystem Design

## Status
Implemented (InMemoryFs, OverlayFs, MountableFs)

## Decision

BashKit uses an async virtual filesystem trait with multiple implementations.

### FileSystem Trait

```rust
#[async_trait]
pub trait FileSystem: Send + Sync {
    // Read operations
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>>;
    async fn stat(&self, path: &Path) -> Result<Metadata>;
    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>>;
    async fn exists(&self, path: &Path) -> Result<bool>;
    async fn read_link(&self, path: &Path) -> Result<PathBuf>;

    // Write operations
    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn append_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn mkdir(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn remove(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn rename(&self, from: &Path, to: &Path) -> Result<()>;
    async fn copy(&self, from: &Path, to: &Path) -> Result<()>;
    async fn symlink(&self, target: &Path, link: &Path) -> Result<()>;
    async fn chmod(&self, path: &Path, mode: u32) -> Result<()>;
}
```

### Public API

All filesystem types are exported from the crate root:

```rust
pub use bashkit::{
    // Trait and types for implementing custom filesystems
    async_trait,       // Re-exported for convenience
    FileSystem,        // The trait to implement
    FileType,          // File/Directory/Symlink enum
    Metadata,          // File metadata struct
    DirEntry,          // Directory entry struct
    Result,            // Result type alias
    Error,             // Error type

    // Built-in implementations
    InMemoryFs,        // In-memory filesystem
    OverlayFs,         // Copy-on-write overlay
    MountableFs,       // Multiple mount points
};
```

### Metadata

```rust
pub struct Metadata {
    pub file_type: FileType,
    pub size: u64,
    pub mode: u32,        // Unix permissions
    pub modified: SystemTime,
    pub created: SystemTime,
}

pub enum FileType {
    File,
    Directory,
    Symlink,
}

pub struct DirEntry {
    pub name: String,
    pub metadata: Metadata,
}
```

#### File Size Reporting

The `size` field in `Metadata` must be set correctly for builtins like `ls -l`, `stat`, and `test -s` to work:

| Entry Type | Expected `size` Value |
|------------|----------------------|
| Regular file | Actual content length in bytes |
| Empty file | `0` |
| Directory | `0` (not the size of contents) |
| Symlink | `0` or length of target path |

**Critical for custom implementations**: Both `stat()` and `read_dir()` must return consistent, accurate sizes. The `DirEntry.metadata.size` returned by `read_dir()` is used directly by `ls -l` without additional `stat()` calls.

**Common pitfall**: When implementing `read_dir()`, ensure directory entries report size `0`, not the size of files within them. See `tests/custom_fs_tests.rs` for reference implementation.

### Implementations

#### InMemoryFs (Implemented)
- All files stored in `HashMap<PathBuf, FsEntry>`
- Thread-safe via `RwLock`
- Initial directories: `/`, `/tmp`, `/home`, `/home/user`, `/dev`
- Special handling for `/dev/null`
- No persistence - state lost on drop
- Synchronous `add_file()` method for pre-population during construction

##### Mounting Files with BashBuilder

The `BashBuilder` provides convenience methods to mount files in the virtual filesystem:

```rust
let mut bash = Bash::builder()
    // Writable file (mode 0o644)
    .mount_text("/config/app.conf", "debug=true\nport=8080\n")
    // Readonly file (mode 0o444)
    .mount_readonly_text("/etc/version", "1.2.3")
    .build();
```

- `mount_text(path, content)` - Creates writable file (mode `0o644`)
- `mount_readonly_text(path, content)` - Creates readonly file (mode `0o444`)
- Parent directories are created automatically
- Works with any filesystem - mounted files are added via an OverlayFs layer

When mounted files are specified, they're added to an OverlayFs layer on top of
the base filesystem. This means:
- The base filesystem remains unchanged
- Mounted files take precedence over base filesystem files
- Works with both default InMemoryFs and custom filesystems

Use cases:
- Configuration files for scripts to read
- Reference data that shouldn't be modified
- Pre-seeding test fixtures
- Simulating system files like `/etc/passwd`

See `examples/text_files.rs` for comprehensive examples.

#### OverlayFs (Implemented)
- Copy-on-write layer over another FileSystem
- Read from base, write to overlay
- Whiteout tracking for deleted files
- Useful for: temp modifications, testing, sandboxing

```rust
pub struct OverlayFs {
    lower: Arc<dyn FileSystem>,
    upper: InMemoryFs,
    whiteouts: RwLock<HashSet<PathBuf>>,
}
```

#### MountableFs (Implemented)
- Mount multiple filesystems at different paths
- Like Unix mount points
- Longest-prefix matching for nested mounts

```rust
pub struct MountableFs {
    root: Arc<dyn FileSystem>,
    mounts: RwLock<BTreeMap<PathBuf, Arc<dyn FileSystem>>>,
}
```

#### RealFs (Planned, Optional)
- Direct access to real filesystem
- Must be explicitly enabled (security)
- Useful for development/testing

### Custom FileSystem Implementations

External crates can implement the FileSystem trait to bridge bashkit to custom storage backends. This is useful for:

1. **Session file stores** - Bridge to external storage during execution
2. **Database-backed filesystems** - Store files in a database
3. **Remote filesystems** - Access files over network protocols
4. **Cached filesystems** - Add caching layers

#### Required Imports

```rust
use bashkit::{
    async_trait, DirEntry, Error, FileSystem, FileType, Metadata, Result,
};
use std::path::{Path, PathBuf};
use std::time::SystemTime;
```

#### Implementation Pattern

```rust
pub struct CustomFileSystem {
    // Your storage backend
}

#[async_trait]
impl FileSystem for CustomFileSystem {
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>> {
        // Delegate to your storage
    }

    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()> {
        // Delegate to your storage
    }

    async fn stat(&self, path: &Path) -> Result<Metadata> {
        let content = self.get_content(path)?;
        let is_dir = self.is_directory(path);
        Ok(Metadata {
            file_type: if is_dir { FileType::Directory } else { FileType::File },
            // IMPORTANT: Files get actual size, directories get 0
            size: if is_dir { 0 } else { content.len() as u64 },
            mode: 0o644,
            modified: SystemTime::now(),
            created: SystemTime::now(),
        })
    }

    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>> {
        let mut entries = Vec::new();
        for child in self.list_children(path)? {
            let is_dir = self.is_directory(&child.path);
            entries.push(DirEntry {
                name: child.name,
                metadata: Metadata {
                    file_type: if is_dir { FileType::Directory } else { FileType::File },
                    // IMPORTANT: Use actual file size, 0 for directories
                    size: if is_dir { 0 } else { child.content.len() as u64 },
                    mode: 0o644,
                    modified: SystemTime::now(),
                    created: SystemTime::now(),
                },
            });
        }
        Ok(entries)
    }

    // ... implement remaining methods
}
```

#### Size Reporting Checklist

When implementing a custom filesystem, verify:

1. **`stat()` returns correct size** - File size matches content length
2. **`read_dir()` entries have correct sizes** - Each `DirEntry.metadata.size` is accurate
3. **Directories always report size 0** - Never inherit child file sizes
4. **Sizes are consistent** - `stat(path).size == read_dir(parent).find(name).metadata.size`

#### Usage

```rust
let custom_fs = Arc::new(CustomFileSystem::new());
let mut bash = Bash::builder().fs(custom_fs).build();
let result = bash.exec("cat /my/file.txt").await?;
```

See `examples/custom_filesystem_impl.rs` for a complete working example.

### Path Handling

All paths normalized before use:
- Resolve `.` and `..` components
- Remove trailing slashes
- Ensure absolute paths start with `/`

```rust
fn normalize_path(path: &Path) -> PathBuf {
    // "/foo/../bar/./baz" -> "/bar/baz"
}
```

### Symlink Handling

Symlinks are stored but intentionally not followed for security:
- **TM-ESC-002**: Prevents symlink escape attacks
- **TM-DOS-011**: Prevents symlink loop DoS attacks

See `specs/006-threat-model.md` for details.

### Special Device Files

#### /dev/null

`/dev/null` is handled at the **interpreter level**, not the filesystem level. This is a security-critical design decision:

- **Writes**: All output redirected to `/dev/null` is silently discarded
- **Reads**: Reading from `/dev/null` returns EOF (empty content)
- **Path normalization**: Handles bypass attempts like `/dev/../dev/null` or `/dev/./null`

**Security Property**: Custom filesystem implementations, overlays, and mount points **cannot** intercept or modify `/dev/null` behavior. This prevents:
- Malicious filesystems from capturing sensitive data written to `/dev/null`
- Unexpected behavior when mounting custom filesystems at `/dev`
- Path traversal attacks attempting to bypass `/dev/null` handling

```rust
// These all behave identically - output is discarded at interpreter level
echo "secret" > /dev/null           // Discarded
echo "secret" > /dev/../dev/null    // Discarded (normalized)
echo "secret" > /dev/./null         // Discarded (normalized)
```

### Error Handling

All operations return `Result<T>` with IO errors:
- `NotFound` - file/directory doesn't exist
- `AlreadyExists` - path already exists
- `Other("is a directory")` - operation not valid for directories
- `Other("not a directory")` - expected directory
- `Other("directory not empty")` - non-recursive delete of non-empty dir

## Alternatives Considered

### Real filesystem with chroot
Rejected because:
- Requires root privileges
- Not portable across OSes
- Doesn't work in WASM

### tokio::fs wrapper
Rejected because:
- Always hits real filesystem
- Can't sandbox or virtualize
- No multi-tenant isolation

## Verification

```rust
#[tokio::test]
async fn test_write_and_read() {
    let fs = InMemoryFs::new();
    fs.write_file(Path::new("/tmp/test"), b"hello").await.unwrap();
    let content = fs.read_file(Path::new("/tmp/test")).await.unwrap();
    assert_eq!(content, b"hello");
}

#[tokio::test]
async fn test_mkdir_recursive() {
    let fs = InMemoryFs::new();
    fs.mkdir(Path::new("/a/b/c"), true).await.unwrap();
    assert!(fs.exists(Path::new("/a")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b/c")).await.unwrap());
}

#[tokio::test]
async fn test_custom_filesystem_integration() {
    // Custom filesystems work with Bash
    let custom_fs = Arc::new(MyCustomFs::new());
    let mut bash = Bash::builder().fs(custom_fs).build();
    let result = bash.exec("echo test > /tmp/file && cat /tmp/file").await.unwrap();
    assert_eq!(result.stdout, "test\n");
}

#[tokio::test]
async fn test_file_size_reporting() {
    // File sizes must be correctly reported by stat() and read_dir()
    let fs = InMemoryFs::new();
    fs.write_file(Path::new("/tmp/file.txt"), b"hello").await.unwrap();
    fs.mkdir(Path::new("/tmp/subdir"), false).await.unwrap();

    // stat() returns correct sizes
    let file_meta = fs.stat(Path::new("/tmp/file.txt")).await.unwrap();
    assert_eq!(file_meta.size, 5); // "hello" = 5 bytes

    let dir_meta = fs.stat(Path::new("/tmp/subdir")).await.unwrap();
    assert_eq!(dir_meta.size, 0); // Directories always 0

    // read_dir() entries have correct sizes
    let entries = fs.read_dir(Path::new("/tmp")).await.unwrap();
    let file_entry = entries.iter().find(|e| e.name == "file.txt").unwrap();
    assert_eq!(file_entry.metadata.size, 5);

    let dir_entry = entries.iter().find(|e| e.name == "subdir").unwrap();
    assert_eq!(dir_entry.metadata.size, 0);
}
```

### Test Coverage

File size reporting is verified by:
- `crates/bashkit/src/builtins/ls.rs` - `test_ls_long_format_*` tests
- `crates/bashkit/tests/custom_fs_tests.rs` - `test_custom_fs_*_size*` tests
