# 003: Virtual Filesystem Design

## Status
Implemented (InMemoryFs, OverlayFs, MountableFs, PosixFs, FsBackend)

## Decision

Bashkit uses a two-layer filesystem abstraction:

| Layer | Trait/Type | Responsibility |
|-------|------------|----------------|
| Backend | `FsBackend` | Raw storage operations (minimal contract) |
| POSIX | `FileSystem` / `PosixFs` | POSIX-like semantics enforcement |

### FsBackend Trait (Raw Storage)

```rust
#[async_trait]
pub trait FsBackend: Send + Sync {
    async fn read(&self, path: &Path) -> Result<Vec<u8>>;
    async fn write(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn append(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn mkdir(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn remove(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn stat(&self, path: &Path) -> Result<Metadata>;
    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>>;
    async fn exists(&self, path: &Path) -> Result<bool>;
    async fn rename(&self, from: &Path, to: &Path) -> Result<()>;
    async fn copy(&self, from: &Path, to: &Path) -> Result<()>;
    async fn symlink(&self, target: &Path, link: &Path) -> Result<()>;
    async fn read_link(&self, path: &Path) -> Result<PathBuf>;
    async fn chmod(&self, path: &Path, mode: u32) -> Result<()>;
}
```

`FsBackend` handles raw storage without enforcing POSIX semantics.
Implementations can be wrapped with `PosixFs` to get type-safe behavior.

### FileSystem Trait (POSIX Semantics)

```rust
#[async_trait]
pub trait FileSystem: Send + Sync {
    // Read operations
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>>;
    async fn stat(&self, path: &Path) -> Result<Metadata>;
    async fn read_dir(&self, path: &Path) -> Result<Vec<DirEntry>>;
    async fn exists(&self, path: &Path) -> Result<bool>;
    async fn read_link(&self, path: &Path) -> Result<PathBuf>;

    // Write operations
    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn append_file(&self, path: &Path, content: &[u8]) -> Result<()>;
    async fn mkdir(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn remove(&self, path: &Path, recursive: bool) -> Result<()>;
    async fn rename(&self, from: &Path, to: &Path) -> Result<()>;
    async fn copy(&self, from: &Path, to: &Path) -> Result<()>;
    async fn symlink(&self, target: &Path, link: &Path) -> Result<()>;
    async fn chmod(&self, path: &Path, mode: u32) -> Result<()>;
}
```

### Public API

All filesystem types are exported from the crate root:

```rust
pub use bashkit::{
    // Traits for implementing custom filesystems
    async_trait,       // Re-exported for convenience
    FsBackend,         // Low-level storage trait (implement this)
    FileSystem,        // High-level POSIX trait

    // Types
    FileType,          // File/Directory/Symlink enum
    Metadata,          // File metadata struct
    DirEntry,          // Directory entry struct
    Result,            // Result type alias
    Error,             // Error type

    // Built-in implementations
    InMemoryFs,        // In-memory filesystem (implements FileSystem)
    OverlayFs,         // Copy-on-write overlay
    MountableFs,       // Multiple mount points
    PosixFs,           // POSIX wrapper for any FsBackend
};
```

### Metadata

```rust
pub struct Metadata {
    pub file_type: FileType,
    pub size: u64,
    pub mode: u32,        // Unix permissions
    pub modified: SystemTime,
    pub created: SystemTime,
}

pub enum FileType {
    File,
    Directory,
    Symlink,
}

pub struct DirEntry {
    pub name: String,
    pub metadata: Metadata,
}
```

#### File Size Reporting

The `size` field in `Metadata` must be set correctly for builtins like `ls -l`, `stat`, and `test -s` to work:

| Entry Type | Expected `size` Value |
|------------|----------------------|
| Regular file | Actual content length in bytes |
| Empty file | `0` |
| Directory | `0` (not the size of contents) |
| Symlink | `0` or length of target path |

**Critical for custom implementations**: Both `stat()` and `read_dir()` must return consistent, accurate sizes. The `DirEntry.metadata.size` returned by `read_dir()` is used directly by `ls -l` without additional `stat()` calls.

**Common pitfall**: When implementing `read_dir()`, ensure directory entries report size `0`, not the size of files within them. See `tests/custom_fs_tests.rs` for reference implementation.

### Implementations

#### InMemoryFs (Implemented)
- All files stored in `HashMap<PathBuf, FsEntry>`
- Thread-safe via `RwLock`
- Initial directories: `/`, `/tmp`, `/home`, `/home/user`, `/dev`
- Special handling for `/dev/null`
- No persistence - state lost on drop
- Synchronous `add_file()` method for pre-population during construction

##### Mounting Files with BashBuilder

The `BashBuilder` provides convenience methods to mount files in the virtual filesystem:

```rust
let mut bash = Bash::builder()
    // Writable file (mode 0o644)
    .mount_text("/config/app.conf", "debug=true\nport=8080\n")
    // Readonly file (mode 0o444)
    .mount_readonly_text("/etc/version", "1.2.3")
    .build();
```

- `mount_text(path, content)` - Creates writable file (mode `0o644`)
- `mount_readonly_text(path, content)` - Creates readonly file (mode `0o444`)
- Parent directories are created automatically
- Works with any filesystem - mounted files are added via an OverlayFs layer

When mounted files are specified, they're added to an OverlayFs layer on top of
the base filesystem. This means:
- The base filesystem remains unchanged
- Mounted files take precedence over base filesystem files
- Works with both default InMemoryFs and custom filesystems

Use cases:
- Configuration files for scripts to read
- Reference data that shouldn't be modified
- Pre-seeding test fixtures
- Simulating system files like `/etc/passwd`

See `examples/text_files.rs` for comprehensive examples.

#### OverlayFs (Implemented)
- Copy-on-write layer over another FileSystem
- Read from base, write to overlay
- Whiteout tracking for deleted files
- Useful for: temp modifications, testing, isolation

```rust
pub struct OverlayFs {
    lower: Arc<dyn FileSystem>,
    upper: InMemoryFs,
    whiteouts: RwLock<HashSet<PathBuf>>,
}
```

#### MountableFs (Implemented)
- Mount multiple filesystems at different paths
- Like Unix mount points
- Longest-prefix matching for nested mounts

```rust
pub struct MountableFs {
    root: Arc<dyn FileSystem>,
    mounts: RwLock<BTreeMap<PathBuf, Arc<dyn FileSystem>>>,
}
```

#### RealFs (Planned, Optional)
- Direct access to real filesystem
- Must be explicitly enabled (security)
- Useful for development/testing

### Custom FileSystem Implementations

#### Which Trait Should I Use?

```
Do you need a custom filesystem?
    │
    ├─ NO → Use InMemoryFs (default with Bash::new())
    │
    └─ YES → Is your storage simple (key-value, database, cloud)?
              │
              ├─ YES → Implement FsBackend + wrap with PosixFs
              │        (POSIX checks are automatic, less code)
              │
              └─ NO → Implement FileSystem directly
                      (full control, you handle all checks)
```

| Approach | Implement | POSIX Checks | Best For |
|----------|-----------|--------------|----------|
| `FsBackend` + `PosixFs` | Raw storage only | Automatic | Databases, cloud, key-value stores |
| `FileSystem` directly | Everything | Manual | Complex caching, custom semantics |

#### Option 1: FsBackend + PosixFs (Recommended)

Best for simple storage backends. You implement raw read/write/list operations,
and `PosixFs` handles all POSIX semantics (type checks, parent directories).

```rust
use bashkit::{async_trait, FsBackend, PosixFs, Bash, Result, Metadata, DirEntry};
use std::sync::Arc;

struct MyStorage { /* your storage */ }

#[async_trait]
impl FsBackend for MyStorage {
    async fn read(&self, path: &Path) -> Result<Vec<u8>> { /* ... */ }
    async fn write(&self, path: &Path, content: &[u8]) -> Result<()> { /* ... */ }
    async fn stat(&self, path: &Path) -> Result<Metadata> { /* ... */ }
    // ... other methods (no POSIX checks needed)
}

// Wrap with PosixFs - POSIX semantics are automatic
let fs = Arc::new(PosixFs::new(MyStorage::new()));
let mut bash = Bash::builder().fs(fs).build();
```

See `examples/custom_backend.rs` for a complete working example.

#### Size Reporting Checklist

When implementing a custom filesystem, verify:

1. **`stat()` returns correct size** - File size matches content length
2. **`read_dir()` entries have correct sizes** - Each `DirEntry.metadata.size` is accurate
3. **Directories always report size 0** - Never inherit child file sizes
4. **Sizes are consistent** - `stat(path).size == read_dir(parent).find(name).metadata.size`

#### Option 2: FileSystem Directly

Best for complex behavior requiring full control. You must implement all
POSIX checks manually.

```rust
use bashkit::{async_trait, FileSystem, fs::fs_errors, Result};

struct MyFs { /* ... */ }

#[async_trait]
impl FileSystem for MyFs {
    async fn write_file(&self, path: &Path, content: &[u8]) -> Result<()> {
        // YOU must check: is path a directory?
        if self.is_directory(path) {
            return Err(fs_errors::is_a_directory());
        }
        // YOU must check: does parent exist?
        if !self.parent_exists(path) {
            return Err(fs_errors::parent_not_found());
        }
        // Now write...
    }
    // ... other methods with manual POSIX checks
}

let fs = Arc::new(MyFs::new());
let mut bash = Bash::builder().fs(fs).build();
```

See `examples/custom_filesystem_impl.rs` for a complete working example.

#### Use Cases

- **Session file stores** - Bridge to external storage during execution
- **Database-backed filesystems** - Store files in a database
- **Remote filesystems** - Access files over network protocols
- **Cached filesystems** - Add caching layers

### Path Handling

All paths normalized before use:
- Resolve `.` and `..` components
- Remove trailing slashes
- Ensure absolute paths start with `/`

```rust
fn normalize_path(path: &Path) -> PathBuf {
    // "/foo/../bar/./baz" -> "/bar/baz"
}
```

### Symlink Handling

Symlinks are stored but intentionally not followed for security:
- **TM-ESC-002**: Prevents symlink escape attacks
- **TM-DOS-011**: Prevents symlink loop DoS attacks

See `specs/006-threat-model.md` for details.

### Special Device Files

#### /dev/null

`/dev/null` is handled at the **interpreter level**, not the filesystem level. This is a security-critical design decision:

- **Writes**: All output redirected to `/dev/null` is silently discarded
- **Reads**: Reading from `/dev/null` returns EOF (empty content)
- **Path normalization**: Handles bypass attempts like `/dev/../dev/null` or `/dev/./null`

**Security Property**: Custom filesystem implementations, overlays, and mount points **cannot** intercept or modify `/dev/null` behavior. This prevents:
- Malicious filesystems from capturing sensitive data written to `/dev/null`
- Unexpected behavior when mounting custom filesystems at `/dev`
- Path traversal attacks attempting to bypass `/dev/null` handling

```rust
// These all behave identically - output is discarded at interpreter level
echo "secret" > /dev/null           // Discarded
echo "secret" > /dev/../dev/null    // Discarded (normalized)
echo "secret" > /dev/./null         // Discarded (normalized)
```

### POSIX Semantics Contract

All `FileSystem` implementations MUST enforce these POSIX-like semantics:

1. **No duplicate names**: A file and directory cannot share the same path.
   - `write_file` on existing directory → error "is a directory"
   - `mkdir` on existing file → error "already exists"

2. **Type-safe operations**:
   - `write_file`/`append_file` MUST fail if path is a directory
   - `mkdir` MUST fail if path exists (file, dir, or symlink), unless `recursive=true` and existing is a directory
   - `read_dir` MUST fail if path is not a directory

3. **Parent directory requirement**:
   - Write operations require parent directory to exist
   - Exception: `mkdir` with `recursive=true` creates parents

Custom implementations can use the `fs_errors` module for consistent error messages:

```rust
use bashkit::fs::fs_errors;

// In write_file implementation:
if path_is_directory {
    return Err(fs_errors::is_a_directory());
}
```

### Error Handling

All operations return `Result<T>` with IO errors:
- `NotFound` - file/directory doesn't exist
- `AlreadyExists` - path already exists (mkdir, file exists at path)
- `Other("is a directory")` - operation not valid for directories (write to dir)
- `Other("not a directory")` - expected directory (read_dir on file)
- `Other("directory not empty")` - non-recursive delete of non-empty dir

## Alternatives Considered

### Real filesystem with chroot
Rejected because:
- Requires root privileges
- Not portable across OSes
- Doesn't work in WASM

### tokio::fs wrapper
Rejected because:
- Always hits real filesystem
- Can't isolate or virtualize
- No multi-tenant isolation

## Verification

```rust
#[tokio::test]
async fn test_write_and_read() {
    let fs = InMemoryFs::new();
    fs.write_file(Path::new("/tmp/test"), b"hello").await.unwrap();
    let content = fs.read_file(Path::new("/tmp/test")).await.unwrap();
    assert_eq!(content, b"hello");
}

#[tokio::test]
async fn test_mkdir_recursive() {
    let fs = InMemoryFs::new();
    fs.mkdir(Path::new("/a/b/c"), true).await.unwrap();
    assert!(fs.exists(Path::new("/a")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b")).await.unwrap());
    assert!(fs.exists(Path::new("/a/b/c")).await.unwrap());
}

#[tokio::test]
async fn test_custom_filesystem_integration() {
    // Custom filesystems work with Bash
    let custom_fs = Arc::new(MyCustomFs::new());
    let mut bash = Bash::builder().fs(custom_fs).build();
    let result = bash.exec("echo test > /tmp/file && cat /tmp/file").await.unwrap();
    assert_eq!(result.stdout, "test\n");
}

#[tokio::test]
async fn test_file_size_reporting() {
    // File sizes must be correctly reported by stat() and read_dir()
    let fs = InMemoryFs::new();
    fs.write_file(Path::new("/tmp/file.txt"), b"hello").await.unwrap();
    fs.mkdir(Path::new("/tmp/subdir"), false).await.unwrap();

    // stat() returns correct sizes
    let file_meta = fs.stat(Path::new("/tmp/file.txt")).await.unwrap();
    assert_eq!(file_meta.size, 5); // "hello" = 5 bytes

    let dir_meta = fs.stat(Path::new("/tmp/subdir")).await.unwrap();
    assert_eq!(dir_meta.size, 0); // Directories always 0

    // read_dir() entries have correct sizes
    let entries = fs.read_dir(Path::new("/tmp")).await.unwrap();
    let file_entry = entries.iter().find(|e| e.name == "file.txt").unwrap();
    assert_eq!(file_entry.metadata.size, 5);

    let dir_entry = entries.iter().find(|e| e.name == "subdir").unwrap();
    assert_eq!(dir_entry.metadata.size, 0);
}
```

### Test Coverage

File size reporting is verified by:
- `crates/bashkit/src/builtins/ls.rs` - `test_ls_long_format_*` tests
- `crates/bashkit/tests/custom_fs_tests.rs` - `test_custom_fs_*_size*` tests
